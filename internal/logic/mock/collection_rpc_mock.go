// Code generated by MockGen. DO NOT EDIT.
// Source: collection_rpc.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	collectionrpc "github.com/xh-polaris/meowchat-collection-rpc/collectionrpc"
	grpc "google.golang.org/grpc"
)

// MockCollectionRpc is a mock of CollectionRpc interface.
type MockCollectionRpc struct {
	ctrl     *gomock.Controller
	recorder *MockCollectionRpcMockRecorder
}

// MockCollectionRpcMockRecorder is the mock recorder for MockCollectionRpc.
type MockCollectionRpcMockRecorder struct {
	mock *MockCollectionRpc
}

// NewMockCollectionRpc creates a new mock instance.
func NewMockCollectionRpc(ctrl *gomock.Controller) *MockCollectionRpc {
	mock := &MockCollectionRpc{ctrl: ctrl}
	mock.recorder = &MockCollectionRpcMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCollectionRpc) EXPECT() *MockCollectionRpcMockRecorder {
	return m.recorder
}

// CreateCat mocks base method.
func (m *MockCollectionRpc) CreateCat(ctx context.Context, in *collectionrpc.CreateCatReq, opts ...grpc.CallOption) (*collectionrpc.CreateCatResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateCat", varargs...)
	ret0, _ := ret[0].(*collectionrpc.CreateCatResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateCat indicates an expected call of CreateCat.
func (mr *MockCollectionRpcMockRecorder) CreateCat(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCat", reflect.TypeOf((*MockCollectionRpc)(nil).CreateCat), varargs...)
}

// DeleteCat mocks base method.
func (m *MockCollectionRpc) DeleteCat(ctx context.Context, in *collectionrpc.DeleteCatReq, opts ...grpc.CallOption) (*collectionrpc.DeleteCatResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteCat", varargs...)
	ret0, _ := ret[0].(*collectionrpc.DeleteCatResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteCat indicates an expected call of DeleteCat.
func (mr *MockCollectionRpcMockRecorder) DeleteCat(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCat", reflect.TypeOf((*MockCollectionRpc)(nil).DeleteCat), varargs...)
}

// ListCat mocks base method.
func (m *MockCollectionRpc) ListCat(ctx context.Context, in *collectionrpc.ListCatReq, opts ...grpc.CallOption) (*collectionrpc.ListCatResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListCat", varargs...)
	ret0, _ := ret[0].(*collectionrpc.ListCatResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCat indicates an expected call of ListCat.
func (mr *MockCollectionRpcMockRecorder) ListCat(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCat", reflect.TypeOf((*MockCollectionRpc)(nil).ListCat), varargs...)
}

// RetrieveCat mocks base method.
func (m *MockCollectionRpc) RetrieveCat(ctx context.Context, in *collectionrpc.RetrieveCatReq, opts ...grpc.CallOption) (*collectionrpc.RetrieveCatResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RetrieveCat", varargs...)
	ret0, _ := ret[0].(*collectionrpc.RetrieveCatResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RetrieveCat indicates an expected call of RetrieveCat.
func (mr *MockCollectionRpcMockRecorder) RetrieveCat(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RetrieveCat", reflect.TypeOf((*MockCollectionRpc)(nil).RetrieveCat), varargs...)
}

// SearchCat mocks base method.
func (m *MockCollectionRpc) SearchCat(ctx context.Context, in *collectionrpc.SearchCatReq, opts ...grpc.CallOption) (*collectionrpc.SearchCatResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SearchCat", varargs...)
	ret0, _ := ret[0].(*collectionrpc.SearchCatResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchCat indicates an expected call of SearchCat.
func (mr *MockCollectionRpcMockRecorder) SearchCat(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchCat", reflect.TypeOf((*MockCollectionRpc)(nil).SearchCat), varargs...)
}

// UpdateCat mocks base method.
func (m *MockCollectionRpc) UpdateCat(ctx context.Context, in *collectionrpc.UpdateCatReq, opts ...grpc.CallOption) (*collectionrpc.UpdateCatResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateCat", varargs...)
	ret0, _ := ret[0].(*collectionrpc.UpdateCatResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateCat indicates an expected call of UpdateCat.
func (mr *MockCollectionRpcMockRecorder) UpdateCat(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCat", reflect.TypeOf((*MockCollectionRpc)(nil).UpdateCat), varargs...)
}
